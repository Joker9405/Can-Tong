import fs from 'fs/promises';import path from 'path';import {kvGet,keyOf,scanEmbKeys} from './kv.js';import {embed,cosine} from './openai.js';
function normalize(s){return (s||'').trim().toLowerCase();}
export default async function handler(req,res){if(req.method!=='POST')return res.status(405).json({error:'Method not allowed'});const {text,src='zhh',tgt='chs',withRelated=false}=req.body||{};const t=normalize(text);let out=text||'';let matched=false;let related=[];
try{const exact=await kvGet(keyOf(src,t));if(exact){matched=true;out=exact[tgt]||text;if(withRelated){related.push({group:'exact',items:{[src]:[t],[tgt]:[exact[tgt]]}});}}}catch(e){}
if(withRelated||!matched){try{const qvec=await embed(text);const keys=await scanEmbKeys(400);const cands=[];for(const k of keys){const obj=await kvGet(k);if(obj&&Array.isArray(obj.vec)){const sim=cosine(qvec,obj.vec);cands.push({sim,ref:obj});}}cands.sort((a,b)=>b.sim-a.sim);const top=cands.filter(x=>x.sim>=0.78).slice(0,8);const groupMap=new Map();for(const c of top){const id=c.ref.group||c.ref.id||c.ref.key;if(!groupMap.has(id))groupMap.set(id,{group:id,items:{},bestSim:c.sim});const pack=groupMap.get(id);(pack.items[c.ref.lang]??=([])).push(c.ref.text);}const groups=Array.from(groupMap.values()).sort((a,b)=>b.bestSim-a.bestSim);if(!matched&&groups.length){const g=groups[0];const tgtList=g.items[tgt]||[];if(tgtList.length){out=tgtList[0];matched=true;}}if(withRelated){related=groups;}}catch(e){}}
if(!matched){try{const base=path.join(process.cwd(),'public','lexicon.json');const raw=await fs.readFile(base,'utf8');const lex=JSON.parse(raw);const arr=Object.values(lex);const item=arr.find(it=>normalize(it[src])===t);if(item&&item[tgt]){matched=true;out=item[tgt];}}catch(e){}}
return res.status(200).json({text:out,meta:{src,tgt,matched},related});}
